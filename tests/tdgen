#!/usr/bin/env python3
#
# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2022 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Author: Antti Laakso <antti.laakso@linux.intel.com>

"""Test data generator, for collecting and creating data used for testing."""

import sys
import logging
from pathlib import Path
from pepclibs.helperlibs import ArgParse, Logging, Procs, SSH, FSHelpers, YAML
from pepclibs.helperlibs.Exceptions import Error

OWN_NAME = "tdgen"
VERSION = "0.1"
LOG = logging.getLogger()
Logging.setup_logger(prefix=OWN_NAME)

MODULE_COMMANDS = {
    "CPUInfo": [
        {"command": "lscpu --physical --all -p=socket,node,core,cpu,online",
         "dirname": "lscpu-topology"},
        {"command": "lscpu",
         "dirname": "lscpu"}]}

def build_arguments_parser():
    """A helper function which parses the input arguments."""

    text = f"{OWN_NAME} - Test data generator, for collecting and creating test data."
    parser = ArgParse.SSHOptsAwareArgsParser(description=text, prog=OWN_NAME, ver=VERSION)

    ArgParse.add_ssh_options(parser)

    text = """Path to the directory to store the output of the commands at. Default value is the
              name of the host the command is run on. See the '-H' option."""
    parser.add_argument("-o", "--outdir", type=Path, default=None, help=text)

    return parser

def parse_arguments():
    """Parse input arguments."""

    parser = build_arguments_parser()
    args = parser.parse_args()

    return args

def get_proc(args):
    """Returns and "SSH" object or the 'Procs' object depending on 'args.hostname'."""

    if args.hostname == "localhost":
        proc = Procs.Proc()
    else:
        proc = SSH.SSH(hostname=args.hostname, username=args.username, privkeypath=args.privkey,
                       timeout=args.timeout)
    return proc

def collect_cmd_output(cmd, proc, outdir):
    """
    Run the command 'cmd' on the remote host. The arguments are as follows.
      * cmd - a dictionary of a command to run, see 'MODULE_COMMANDS'.
      * proc - a 'Proc' or 'SSH' objetc that defines the remote host to run the 'cmd' on.
      * outdir - the directory to save the command output to.
    """

    cmdpath = outdir / cmd["dirname"]

    if FSHelpers.exists(cmdpath) and not FSHelpers.isdir(cmdpath):
        raise Error(f"command output path '{cmdpath}' exists and is not a directory")

    FSHelpers.mkdir(cmdpath, parents=True, exist_ok=True)

    stdout, stderr = proc.run_verify(cmd["command"])

    for fname, data in ("stdout", stdout), ("stderr", stderr):
        path = cmdpath / f"{fname}.txt"

        with open(path, "w") as fobj:
            fobj.write(data)

def main():
    """Script entry point."""

    try:
        args = parse_arguments()
        proc = get_proc(args)

        outdir = args.outdir
        if not outdir:
            outdir = Path(proc.hostname)

        for module, commands in MODULE_COMMANDS.items():
            for command in commands:
                collect_cmd_output(command, proc, outdir)
            YAML.dump({"commands" : commands}, outdir / f"{module}.yaml")

    except KeyboardInterrupt:
        LOG.info("\nInterrupted, exiting")
        return -1
    except Error as err:
        LOG.error(err)
        return -1

    return 0

if __name__ == "__main__":
    sys.exit(main())

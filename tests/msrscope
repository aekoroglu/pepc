#!/usr/bin/env python3
#
# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2023 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Author: Niklas Neronin <niklas.neronin@intel.com>

"""MSR scope checker, for checking the scope for a writable MSR."""

import sys
import logging

try:
    import argcomplete
except ImportError:
    # We can live without argcomplete, we only lose tab completions.
    argcomplete = None

from pepctool._Pepc import ArgParse
from pepclibs.helperlibs.Exceptions import Error
from pepclibs.helperlibs import Logging, ProcessManager
from pepclibs.msr import MSR
from pepclibs import CPUInfo

TOOLNAME = "msrscope"
VERSION = "0.1"
_LOG = logging.getLogger()
Logging.setup_logger(prefix=TOOLNAME)

def _find_msr_scope(args, cpuinfo, msr):
    """Tries to figure out the scope of an MSR."""

    info = {}
    # Collect initial values for all online CPUs.
    for cpu, val in msr.read_bits(args.regaddr, args.bits):
        info[cpu] = val

    cpus = set()
    # Set CPU 'args.cpu' to different values and record all CPUs which values have changed. The
    # should be set to min. 2 values, this prevents the value being set to the same value.
    for value in args.values:
        value = int(value)
        msr.write_bits(args.regaddr, args.bits, value, cpus=(args.cpu, ))
        if value != msr.read_cpu_bits(args.regaddr, args.bits, args.cpu):
            raise Error(f"failed to write value '{value}' to MSR 0x{args.regaddr:x} bits "
                        f"{':'.join(args.bits)}")

        for cpu, val in msr.read_bits(args.regaddr, args.bits):
            if info[cpu] != val:
                cpus.add(cpu)

    # Find common scope shared by all the modified CPUs.
    scopes = []
    if len(cpus) == 1:
        scopes.append("CPU")

    topology = cpuinfo.get_topology()
    tinfo = cpuinfo.get_cpu_levels(args.cpu)
    for scope in ("core", "module", "die", "package"):
        for tline in topology:
            if tline["CPU"] in cpus:
                if tline[scope] != tinfo[scope]:
                    break
            elif tline[scope] == tinfo[scope]:
                # Scopes 'core' and 'die' are per-package.
                if scope in {"core", "die"} and tline["package"] != tinfo["package"]:
                    continue
                break
        else:
            scopes.append(scope)

    # Restore the changed CPUs to their initial values. Due to them all sharing the same scope, only
    # 'args.cpu' needs to be write to.
    msr.write_bits(args.regaddr, args.bits, info[args.cpu], cpus=(args.cpu, ))
    val = msr.read_cpu_bits(args.regaddr, args.bits, args.cpu)
    _LOG.debug("initial value was '%d' and value after test is '%d'.", info[args.cpu], val)

    return scopes

def _build_arguments_parser():
    """A helper function which parses the input arguments."""

    text = f"""{TOOLNAME} - Tool for checking an MSRs scope. On some systems the tool might print
               multiple possible scopes, this is due to that some scopes might be identical. For
               example, die, node and package might share the exact same CPUs, rendering it
               impossible to verify which one is the correct scope."""
    parser = ArgParse.SSHOptsAwareArgsParser(description=text, prog=TOOLNAME, ver=VERSION)
    ArgParse.add_ssh_options(parser)

    text = """The MSR register address."""
    parser.add_argument("regaddr", help=text)

    text = """The bits, by default \"0:0\"."""
    parser.add_argument("--bits", help=text, default="0:0")
    text = """Two unique values to set the MSR register to. After the test, the MSR will be restored
              to the values before the test."""
    parser.add_argument("--values", nargs=2, help=text, default=[0, 1])
    text = """The CPU which MSR will be writen to, by default CPU 0."""
    parser.add_argument("--cpu", type=int, help=text, default=0)

    if argcomplete:
        argcomplete.autocomplete(parser)

    return parser

def _parse_arguments():
    """Parse input arguments."""

    parser = _build_arguments_parser()
    args = parser.parse_args()

    return args

def main():
    """Script entry point."""

    try:
        args = _parse_arguments()

        # pylint: disable=no-member
        if args.hostname == "localhost":
            args.username = args.privkey = args.timeout = None

        with ProcessManager.get_pman(args.hostname, username=args.username,
                                     privkeypath=args.privkey, timeout=args.timeout) as pman, \
             CPUInfo.CPUInfo(pman=pman) as cpuinfo, \
             MSR.MSR(pman, cpuinfo=cpuinfo, enable_cache=False) as msr:

            if cpuinfo.get_offline_cpus_count():
                raise Error("please online all CPUs")

            # Argument 'regaddr' can either be an decimal or hex.
            try:
                args.regaddr = int(args.regaddr)
            except (ValueError, TypeError):
                try:
                    args.regaddr = int(args.regaddr, 16)
                except (ValueError, TypeError):
                    raise Error("please supply register addres in decimal or hex") from None

            args.bits = args.bits.split(":")
            if len(args.bits) != 2:
                raise Error("please supply bits in the following format \"h:l\"")

            cpuinfo.normalize_cpu(args.cpu)

            scopes = _find_msr_scope(args, cpuinfo, msr)
            if len(scopes) == 1:
                _LOG.info("The scope for MSR %#x bits %s is %s.", args.regaddr, ":".join(args.bits),
                          scopes[0])
            elif scopes:
                _LOG.info("The possible scopes for MSR %#x bits %s are %s.\nThese scopes are "
                          "identical%s.", args.regaddr, ":".join(args.bits), ", ".join(scopes),
                          pman.hostmsg)
            else:
                # Probably a new scope that we are not aware of.
                _LOG.info("Could not determine the scope for MSR %#x bits %s.\nPlease, contact "
                          "project maintainers.", args.regaddr, ":".join(args.bits))

    except KeyboardInterrupt:
        _LOG.info("\nInterrupted, exiting")
        return -1
    except Error as err:
        _LOG.error_out(err)

    return 0

if __name__ == "__main__":
    sys.exit(main())
